![screen1](https://github.com/kcherenkovv/MLOps_project/blob/main/scrins/example_of_work.png)


**Команда:**

Кирилл Реченков 

Николай Шешин

Серафим Загородний

Екатерина Таратута

Михиал Симаков




**Версионирования датасета на удалённом репозитории в googleDrive:**
![screen1](https://github.com/kcherenkovv/MLOps_project/blob/main/scrins/dvc_example.png)





**Датасет** 

https://drive.google.com/drive/folders/1AFZ7-dMZLfXwDyBfSURczp8jpYz2qf-p





**Проект выполнен согласно поставленному заданию и включает следующие основные компоненты и функциональности:**


**Оркестрация с помощью CI/CD (Jenkins)**

  Для оркестрации процессов разработки и развертывания использован инструмент CI/CD - Jenkins.
  
  Jenkins автоматизирует сборку, тестирование и развертывание нашего приложения, обеспечивая непрерывность и надежность процессов.

Вот описание Jenkins Pipeline, который автоматизирует процесс развертывания проекта из репозитория Git, установки необходимых зависимостей, запуска модульных тестов и создания Docker-образа.

Основные этапы выполнения Pipeline:

Start: Простой этап, в котором выводится текст "Начало работы скриптов".

Preparation: На этом этапе происходит очистка рабочего пространства и загрузка кода из репозитория Git.

Checkout: Здесь происходит получение исходного кода из ветки main репозитория, указанного по URL.

Setup Virtual Environment: На этом этапе создается виртуальное окружение для изоляции зависимостей проекта.

Activate venv: В данном шаге активируется виртуальное окружение для использования установленных зависимостей.

Install Dependencies: Здесь происходит установка всех зависимостей проекта из файла requirements.txt.

Run Unit Tests: На этом этапе запускаются модульные тесты проекта с помощью pytest.

Build Docker image: В этом шаге создается Docker-образ проекта. Для этого используется Dockerfile из репозитория.

После завершения всех этапов, в блоке post будет выводиться сообщение "Pipeline completed." независимо от результата выполнения.

Pipeline позволяет автоматизировать процесс сборки, тестирования и развертывания проекта, что повышает производительность и упрощает его обслуживание.
  
  
**Версионирование данных с использованием DVC**

  Для управления версиями данных в проекте используется инструмент версионирования данных DVC.
  
  Датасеты версионируются, синхронизируются с удаленным хранилищем и обеспечивают возможность восстановления данных в прошлых версиях.
  
**Разработка функциональных возможностей в отдельных ветках**

  Разработка новых функций и обновлений приложения проводится в отдельных ветках репозитория.
  
  Наборы фичей и версии данных также управляются в рамках соответствующих веток, обеспечивая структурированный и удобный процесс разработки.
  
**Запуск модульных тестов и проверка данных на качество**

  В рамках нашего CI/CD конвейера запускаются как модульные тесты приложения, так и проверка качества данных.
  
  Это позволяет обеспечить высокое качество кода и данных, а также быструю обратную связь разработчикам.
  
  Тестирование происходит следующим образом (представлен набор юнит-тестов для проверки функциональности модуля image_processing.py):

test_generate_image_description_image_string: Тест проверяет, что функция generate_image_description правильно обрабатывает путь к изображению и возвращает строку описания изображения.

test_generate_image_description_image_string_bad_path: Тест проверяет, что функция корректно обрабатывает случай с некорректным путем к изображению и выбрасывает исключение FileNotFoundError.

test_generate_image_description_image_bytes: Тест проверяет, что функция generate_image_description корректно обрабатывает изображение, представленное в виде последовательности байт.

test_generate_image_description_image_pillow: Тест проверяет, что функция корректно обрабатывает изображение, представленное объектом PIL.Image.

test_generate_image_description_image_unknown_type: Тест проверяет правильную обработку недопустимого типа данных изображения, в данном случае целое число.

Последние три строки if __name__ == '__main__': pytest.main() указывают, что если этот скрипт запущен непосредственно (а не импортирован в другой скрипт), то он выполнит все определенные тесты с использованием библиотеки pytest.

Общий смысл этих тестов - проверить корректность работы функции generate_image_description на различных типах входных данных (строка с путем к файлу, последовательность байт, объект Image из библиотеки Pillow) и на некорректных входных данных (например, неверный путь к файлу или недопустимый тип данных).

  
**Реализация итогового приложения в виде Docker образа**

  Итоговое приложение реализовано в виде Docker образа, что обеспечивает удобство и портабельность при развертывании.
  
  Сборка Docker образа происходит в рамках нашего CI/CD конвейера, автоматизируя процесс развертывания.

  Создание контейнера Docker, в котором будет запускаться приложение на Python с использованием библиотеки Streamlit, происходит так:
  

FROM python:3.9-slim: Указывает базовый образ, который будет использоваться для создания контейнера. В данном случае используется образ с Python версии 3.9 в урезанной версии slim, что позволяет уменьшить размер итогового образа.

Команда COPY: Копирует необходимые файлы из локальной директории внутрь контейнера. В данном случае копируются файлы image_processing.py, main.py и requirements.txt в директорию /app контейнера.
WORKDIR /app: Устанавливает рабочую директорию внутри контейнера для последующих команд.

RUN pip install -r requirements.txt: Устанавливает необходимые зависимости, указанные в файле requirements.txt, используя менеджер пакетов pip.

CMD ["streamlit", "run", "main.py"]: Эта команда задает, что при запуске контейнера будет выполнена команда streamlit run main.py, что запускает приложение Streamlit, основное управление которого будет обеспечиваться файлом main.py.

Таким образом, данный Dockerfile определяет окружение контейнера с необходимыми зависимостями, копирует файлы приложения, устанавливает команду для запуска приложения на Streamlit через файл main.py.

